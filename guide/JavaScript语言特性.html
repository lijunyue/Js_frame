<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Liuyun Blog</title>
    <meta name="description" content="个人在前端开发过程中整理的全栈知识">
    <link rel="icon" href="/logo.png">
    
    <link rel="preload" href="/assets/css/0.styles.cc2a2ebf.css" as="style"><link rel="preload" href="/assets/js/app.179fdb04.js" as="script"><link rel="preload" href="/assets/js/13.d30963c3.js" as="script"><link rel="prefetch" href="/assets/js/23.62c86287.js"><link rel="prefetch" href="/assets/js/2.cda51ec0.js"><link rel="prefetch" href="/assets/js/3.d9e4f004.js"><link rel="prefetch" href="/assets/js/4.89782e16.js"><link rel="prefetch" href="/assets/js/5.b88fe57b.js"><link rel="prefetch" href="/assets/js/6.a593a008.js"><link rel="prefetch" href="/assets/js/7.5de1569e.js"><link rel="prefetch" href="/assets/js/8.fe4249fe.js"><link rel="prefetch" href="/assets/js/9.979c7cc3.js"><link rel="prefetch" href="/assets/js/10.d3c0468d.js"><link rel="prefetch" href="/assets/js/11.78d628ba.js"><link rel="prefetch" href="/assets/js/12.a09bf4c7.js"><link rel="prefetch" href="/assets/js/14.2f465d9a.js"><link rel="prefetch" href="/assets/js/15.8faf7082.js"><link rel="prefetch" href="/assets/js/16.480ac2ea.js"><link rel="prefetch" href="/assets/js/17.dbd2c19f.js"><link rel="prefetch" href="/assets/js/18.0728f048.js"><link rel="prefetch" href="/assets/js/19.2e57d3d7.js"><link rel="prefetch" href="/assets/js/20.b45cef85.js"><link rel="prefetch" href="/assets/js/21.da673e5a.js"><link rel="prefetch" href="/assets/js/22.0adb5271.js"><link rel="prefetch" href="/assets/js/24.5c80a2bb.js"><link rel="prefetch" href="/assets/js/25.7290e58d.js"><link rel="prefetch" href="/assets/js/26.2767c10d.js"><link rel="prefetch" href="/assets/js/27.89b69b2f.js"><link rel="prefetch" href="/assets/js/28.2cf3b2c5.js"><link rel="prefetch" href="/assets/js/29.2545ca7e.js"><link rel="prefetch" href="/assets/js/30.802a91cb.js"><link rel="prefetch" href="/assets/js/31.1b6da1b5.js"><link rel="prefetch" href="/assets/js/32.9e994f0a.js"><link rel="prefetch" href="/assets/js/33.34ee87b9.js"><link rel="prefetch" href="/assets/js/34.a5fa4c30.js"><link rel="prefetch" href="/assets/js/35.34ae4516.js"><link rel="prefetch" href="/assets/js/36.7d4adbea.js"><link rel="prefetch" href="/assets/js/37.39bfa8e7.js"><link rel="prefetch" href="/assets/js/38.85086c4c.js"><link rel="prefetch" href="/assets/js/39.ec5ca575.js"><link rel="prefetch" href="/assets/js/40.bec19f6e.js"><link rel="prefetch" href="/assets/js/41.e00424d9.js"><link rel="prefetch" href="/assets/js/42.45f73e33.js"><link rel="prefetch" href="/assets/js/43.896dfa1e.js"><link rel="prefetch" href="/assets/js/44.cd8a0728.js"><link rel="prefetch" href="/assets/js/45.830001ab.js"><link rel="prefetch" href="/assets/js/46.b9361b43.js"><link rel="prefetch" href="/assets/js/47.67fa6b04.js">
    <link rel="stylesheet" href="/assets/css/0.styles.cc2a2ebf.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Liuyun Blog</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">前端指南</a></div><div class="nav-item"><a href="/utils/" class="nav-link">辅助工具</a></div><div class="nav-item"><a href="/full-stack/" class="nav-link">全栈集锦</a></div><div class="nav-item"><a href="/others/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://liuyun012.github.io/xes-wxapp/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  xes-wxapp
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/liuyun012/Js_frame/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/guide/" class="nav-link router-link-active">前端指南</a></div><div class="nav-item"><a href="/utils/" class="nav-link">辅助工具</a></div><div class="nav-item"><a href="/full-stack/" class="nav-link">全栈集锦</a></div><div class="nav-item"><a href="/others/" class="nav-link">其他</a></div><div class="nav-item"><a href="https://liuyun012.github.io/xes-wxapp/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  xes-wxapp
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="https://github.com/liuyun012/Js_frame/" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>前端指南</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/guide/" class="sidebar-link">前端开发指南</a></li><li><a href="/guide/html-head.html" class="sidebar-link">常用html &lt;meta&gt;</a></li><li><a href="/guide/css问题汇总.html" class="sidebar-link">CSS 语法整理</a></li><li><a href="/guide/JavaScript语言特性.html" class="active sidebar-link">/guide/JavaScript语言特性.html</a></li><li><a href="/guide/JavaScript基础操作汇总.html" class="sidebar-link">JavaScript 基础操作汇总</a></li><li><a href="/guide/JavaScript学习知识积累.html" class="sidebar-link">JavaScript学习知识积累</a></li><li><a href="/guide/JavaScript问题汇总.html" class="sidebar-link">JavaScript 常见问题汇总</a></li><li><a href="/guide/前端编码规范整理.html" class="sidebar-link">前端编码规范 -- 项目整理</a></li><li><a href="/guide/常用正则表达式整理汇总.html" class="sidebar-link">JavaScript正则表达式整理汇总</a></li><li><a href="/guide/jade语法.html" class="sidebar-link">Jade 语法整理</a></li><li><a href="/guide/原生操作DOM汇总.html" class="sidebar-link">原生JavaScript DOM操作汇总</a></li><li><a href="/guide/Vue日常项目学习整理汇总.html" class="sidebar-link">/guide/Vue日常项目学习整理汇总.html</a></li><li><a href="/guide/React 日常项目学习整理汇总.html" class="sidebar-link">/guide/React 日常项目学习整理汇总.html</a></li><li><a href="/guide/React-Router4.0使用汇总.html" class="sidebar-link">/guide/React-Router4.0使用汇总.html</a></li><li><a href="/guide/快应用踩坑集锦.html" class="sidebar-link">快应用开发过程踩坑集锦汇总</a></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><p>一、JavaScript基本的语言特性</p> <ul><li>基本类型和引用类型
<ol><li>基本类型：string, number, boolean, null, undefined</li> <li>引用类型：Function, Array, Object</li> <li>访问方式：基本类型 -- 操作和保存在变量的实际的值；引用类型：值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用。</li></ol></li> <li>函数声明和函数表达式
<code>function</code>关键字用来在一个表达式定义一个函数，也可以使用<code>Function</code>构造函数和一个函数声明来定义函数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 方法一：函数声明
function foo() {}

// 方法二：函数表达式
var foo = function() {};
</code></pre></div><p>第三种自执行函数表达式，主要用于创建一个新的作用域，在此作用域内声明的变量不会和其他作用域内的变量冲突或混淆，大多是以匿名方式存在，且立即执行：</p> <div class="language- extra-class"><pre class="language-text"><code>(function () {
	// var x = ...
})();
</code></pre></div><p>javascript存在变量声明被提升的机制，函数声明的方式会将这个函数变量提升到作用域的最前面，函数表达式的写法只会将var声明的变量提升，并先赋值为 <code>undefined</code>;</p> <ul><li>JSON ：JSON.parse -- 将JSON字符串反序列化成对象； JSON.stringify -- 将对象序列化成JSON字符串。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 这是JSON字符串
var foo = '{ &quot;prop&quot;: &quot;val&quot;}';

// 这是对象字面量
var bar = { &quot;prop&quot;: &quot;val&quot;};
</code></pre></div><ul><li><p>原型及原型链</p> <ul><li>原型：每一个JavaScript对象在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&quot;继承&quot;属性</li> <li>构造函数: 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Person() {

}
var person = new Person();
person.name = 'Kevin';
console.log(person.name)  // Kevin
</code></pre></div><ul><li>prototype属性：Object.prototype表示实例原型</li> <li><code>__proto__</code>: 每个JavaScript对象都具有的一个属性，该属性指向对象的原型。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Person() {

}
var person = new Person();
console.log(person.__proto__ === Person.prototype); // true
</code></pre></div><ul><li>constructor: 每个原型都有一个constructor属性指向关联的构造函数。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function Person() {

}

var person = new Person();
console.log(person.__proto__ == Person.prototype) // true
console.log(Person.prototype.constructor == Person) // true
</code></pre></div><ul><li>原型链：由相互关联的原型组成的链状结构就是原型链。</li> <li>每一个对象都会从原型&quot;继承&quot;属性的本质：JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数。</li></ul></li> <li><p>变量对象</p> <ul><li>变量数据是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</li> <li>全局对象：是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。</li> <li>在函数上下文中，变量对象包括：函数的所有形参，函数声明，变量声明。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>alert(x);      // function
var x = 10;
alert(x);      // 10
x = 20;
function x() {};
alert(x);      // 20
</code></pre></div></li> <li><p>this</p> <ul><li>在一个函数上下文中，this由调用者提供，由调用函数的方式决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的 base对象。当this值为null是，其值会被隐士转换为全局对象。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>(function () {
  alert(this); // null =&gt; global
})();
</code></pre></div><ul><li>局部变量，内部函数，形式参数存储在给定函数的激活对象中</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
   function bar() {
      alert(this); // global 全局对象
   }
   bar(); // the same as AO.bar()
}
</code></pre></div></li> <li><p>闭包</p> <ul><li><p>定义：能够读取其他函数内部变量的函数或定义在一个函数内部的函数。</p></li> <li><p>自由变量：指在函数中使用，但既不是函数参数也不是函数的局部变量的变量。</p></li> <li><p>用途： 一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。</p></li> <li><p>使用注意点：</p> <ol><li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li> <li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li></ol></li></ul></li> <li><p>斐波那契数列函数实现</p> <div class="language- extra-class"><pre class="language-text"><code>function fib(max) {
	var t,a=0,b=1,arr=[0, 1];
	while (arr.length &lt; max) {
		[a, b] = [b, a+b];
		arr.push(b);
	}
	return arr;
}
// 测试：
fib(5);  // [0, 1, 1, 2, 3]
fib(10);  // [0,1,1,2,3,5,8,13,21,34]
</code></pre></div></li></ul> <p>二、Web安全问题</p> <ul><li>XSS攻击：对Web页面注入脚本，使用JavaScript窃取用户信息，诱导用户操作。</li> <li>CSRF攻击：伪造用户请求向网站发起恶意请求。</li> <li>钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。</li> <li>HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。</li> <li>远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对的情况下就执行命令。</li></ul> <p>三、Web安全解决方案</p> <ul><li>提供各种过滤模板函数，防止钓鱼或xss攻击；</li> <li>添加常见的Web安全头的支持；</li> <li>CSRF的防御方案；</li> <li>定制白名单，用于安全跳转和url过滤；</li> <li>各种模板相关的工具函数做预处理；</li></ul> <p>四、常规知识点</p> <ul><li><p>SVN和Git的区别：</p> <ul><li>SVN优点：集中式服务器，已于管理，安全性高，管理方便。代码一致性高，适合开发人数不多的项目开发。</li> <li>Svn缺点：服务器压力太大，数据库容量暴增。离线无法工作。</li> <li>Git优点：分布式开发，公共服务器压力和数据量都不大，速度快，灵活，容易解决冲突，可离线工作。</li> <li>Git缺点：学习周期相对比较长，代码保密性差，库克隆就可以完全公开所有代码和版本信息。</li></ul></li> <li><p>栈内存和堆内存的区别：基本类型一般保存在栈内存，引用类型指保存在堆内存的对象。</p></li> <li><p>从输入URL到页面加载的过程：</p> <ol><li>在浏览器地址栏中输入url</li> <li>浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</li> <li>需要域名解析(DNS解析)，解析获取相应的IP地址；</li> <li>浏览器根据IP地址与服务器建立socket连接；(三次握手连接，TCP协议)</li> <li>浏览器与服务器通信：浏览器请求，服务器处理请求；</li> <li>说明：浏览器根据URL 内容生成 HTTP请求，请求中包含请求文件的位置、请求文件的方式等；服务器接到请求后，根据HTTP请求中的内容来决定如何获取相应的HTML文件；服务器将得到的HTMLwenj发送给浏览器；在浏览器还没有完全接收HTML文件时便开始渲染、显示网页；在执行HTML中代码时，根据需要，浏览器会继续请求网页、CSS、JavaScript等文件。</li> <li>浏览器接收到HTTP响应</li> <li>读取页面内容，浏览器渲染，解析html源码</li> <li>生成Dom树，解析css样式，js交互</li> <li>浏览器与服务器断开连接</li></ol></li> <li><p>页面优化方案</p> <ol><li>减少http请求，合理设置HTTP缓存；</li> <li>使用浏览器缓存，在http请求头设置 cache-control 和 expires属性，可设定浏览器缓存。</li> <li>启用压缩，在服务器端对文件进行压缩，在浏览器端对文件解压缩，减少通信传输的数据量。</li> <li>CSS Sprites，合并CSS图片，减少请求，或者使用svg字体图标；</li> <li>图片懒加载，优先加载首屏图片，剩余图片滚动是再加载；</li> <li>CSS文件放在页面最上部，JavaScript文件放在页面最下面；</li> <li>减少cookie传输，太大的cookie会严重影响数据传输，考虑静态资源使用独立域名访问。</li> <li>JavaScript代码优化：尽量少的操作DOM,减少页面的重排和重绘；减少作用域链的查找，优化数据大操作，减少字符串的拼接</li> <li>CSS选择符优化：减少ID和元素类名的使用，减少类名的嵌套层级</li> <li>使用CDN加速缓存</li> <li>反向代理</li></ol></li> <li><p>跨域解决方案</p> <ul><li>定义：一个域下的文档或脚本试图去请求另一个域下的资源，狭义上指由浏览器同源策略限制的一类请求场景。</li> <li>同源策略/SOP：一种约定，浏览器核心和最基本的安全功能，所谓同源是指&quot;协议+域名+端口&quot;三者相同。即便两个不同的域名指向同一个ip地址，也非同源。</li> <li>同源限制的行为：1. Cookie、LocalStorage 和 IndexDB 无法获取。2. DOM 和 JS 对象无法获得。 3. AJAX 请求不能发送。</li> <li>常见的解决方案：1、通过 jsonp 跨域；2、iframe跨域；3、postMessage跨域；4、跨域资源共享(CORS); 5、nginx代理跨域；6、nodejs中间件代理跨域；7、WebSocket协议跨域。</li></ul> <ol><li><p>通过jsonp跨域方案</p> <ul><li>通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名的服务器上面。在html页面中再通过相应的标签从不同域名下加载静态资源，被浏览器允许。故可通过动态创建script，再请求一个带参网址实现跨域通信。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>// 通过原生实现
&lt;script&gt;
	var script = document.createElement('script');
	script.type = 'text/javascript';
	
	// 传参并指定回调执行函数为 onBack
	script.src = 'http://www.domain2.com:8080/login?user=admin&amp;callback=onBack';
	document.head.appendChild(script);
	
	// 回调执行函数
	function onBack(res) {
		alert(JSON.stringify(res));
	}
&lt;/script&gt;
</code></pre></div><p>缺点：只能实现 get 一种请求。</p></li> <li><p>postMessage跨域</p> <ul><li>用法：postMessage(data, origin),接收两个参数：data -- 任意基本类型或可复制对象。origin: 协议+主机+端口号，也可设置为&quot;*&quot;。同源可设置为&quot;/&quot;;</li> <li>解决问题：a. 页面和其打开的新窗口的数据传递；b.多窗口之间消息传递；c.页面与嵌套的iframe消息传递。d.上面三个场景的跨数据传递。</li></ul></li> <li><p>跨资源共享(CORS)
普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。但由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie,而非当前页，需做代理设置。</p></li> <li><p>nginx代理跨域</p> <ul><li><p>nginx配置解决iconfont跨域</p> <div class="language- extra-class"><pre class="language-text"><code>location / {
	add_header Access-Control-Allow-Origin *;
}
</code></pre></div></li> <li><p>nginx反向代理接口跨域</p> <ol><li>跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨域问题。</li> <li>实现思路：通过nginx配置一个代理服务器(域名相同，端口不同)做跳板，反向代理访问domain2接口，并顺便修改cookie中的domain信息，方便当前域cookie写入，实现跨域登录。
nginx的具体配置</li></ol> <div class="language- extra-class"><pre class="language-text"><code>#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
</code></pre></div><p>前端代码实例：</p> <div class="language- extra-class"><pre class="language-text"><code>var xhr = new XMLHttpRequest();

// 前端开关：浏览器是否读写cookie
xhr.withCredentials = true;

// 访问nginx中的代理服务器
xhr.open('get', 'http://www.domain1.com:81/?user=admin', true);
xhr.send();
</code></pre></div></li></ul></li> <li><p>WebSocket协议跨域：HTML5新的协议，实现了浏览器与服务器全双工通信，同时允许跨域通讯。</p></li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 前端代码实现
&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;
&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
var socket = io('http://www.domain2.com:8080');

// 连接成功处理
socket.on('connect', function() {
    // 监听服务端消息
    socket.on('message', function(msg) {
        console.log('data from server: ---&gt; ' + msg); 
    });

    // 监听服务端关闭
    socket.on('disconnect', function() { 
        console.log('Server socket has closed.'); 
    });
});

document.getElementsByTagName('input')[0].onblur = function() {
    socket.send(this.value);
};
&lt;/script&gt;
</code></pre></div></li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/13.d30963c3.js" defer></script><script src="/assets/js/app.179fdb04.js" defer></script>
  </body>
</html>
