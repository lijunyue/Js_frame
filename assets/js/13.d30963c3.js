(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{190:function(n,t,e){"use strict";e.r(t);var a=e(0),v=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,t=n.$createElement,e=n._self._c||t;return e("div",{staticClass:"content"},[e("p",[n._v("一、JavaScript基本的语言特性")]),n._v(" "),e("ul",[e("li",[n._v("基本类型和引用类型\n"),e("ol",[e("li",[n._v("基本类型：string, number, boolean, null, undefined")]),n._v(" "),e("li",[n._v("引用类型：Function, Array, Object")]),n._v(" "),e("li",[n._v("访问方式：基本类型 -- 操作和保存在变量的实际的值；引用类型：值保存在内存中，js不允许直接访问内存，在操作的时候，操作的是对象的引用。")])])]),n._v(" "),e("li",[n._v("函数声明和函数表达式\n"),e("code",[n._v("function")]),n._v("关键字用来在一个表达式定义一个函数，也可以使用"),e("code",[n._v("Function")]),n._v("构造函数和一个函数声明来定义函数。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 方法一：函数声明\nfunction foo() {}\n\n// 方法二：函数表达式\nvar foo = function() {};\n")])])]),e("p",[n._v("第三种自执行函数表达式，主要用于创建一个新的作用域，在此作用域内声明的变量不会和其他作用域内的变量冲突或混淆，大多是以匿名方式存在，且立即执行：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("(function () {\n\t// var x = ...\n})();\n")])])]),e("p",[n._v("javascript存在变量声明被提升的机制，函数声明的方式会将这个函数变量提升到作用域的最前面，函数表达式的写法只会将var声明的变量提升，并先赋值为 "),e("code",[n._v("undefined")]),n._v(";")]),n._v(" "),e("ul",[e("li",[n._v("JSON ：JSON.parse -- 将JSON字符串反序列化成对象； JSON.stringify -- 将对象序列化成JSON字符串。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('// 这是JSON字符串\nvar foo = \'{ "prop": "val"}\';\n\n// 这是对象字面量\nvar bar = { "prop": "val"};\n')])])]),e("ul",[e("li",[e("p",[n._v("原型及原型链")]),n._v(" "),e("ul",[e("li",[n._v('原型：每一个JavaScript对象在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性')]),n._v(" "),e("li",[n._v("构造函数: 当通过new来创建一个新对象时，JS底层将新对象的原型链指向了构造函数的原型对象，在新对象和函数对象之间建立了一条原型链，通过新对象可以访问到函数对象原型prototype中的方法和属性。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person() {\n\n}\nvar person = new Person();\nperson.name = 'Kevin';\nconsole.log(person.name)  // Kevin\n")])])]),e("ul",[e("li",[n._v("prototype属性：Object.prototype表示实例原型")]),n._v(" "),e("li",[e("code",[n._v("__proto__")]),n._v(": 每个JavaScript对象都具有的一个属性，该属性指向对象的原型。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person() {\n\n}\nvar person = new Person();\nconsole.log(person.__proto__ === Person.prototype); // true\n")])])]),e("ul",[e("li",[n._v("constructor: 每个原型都有一个constructor属性指向关联的构造函数。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Person() {\n\n}\n\nvar person = new Person();\nconsole.log(person.__proto__ == Person.prototype) // true\nconsole.log(Person.prototype.constructor == Person) // true\n")])])]),e("ul",[e("li",[n._v("原型链：由相互关联的原型组成的链状结构就是原型链。")]),n._v(" "),e("li",[n._v('每一个对象都会从原型"继承"属性的本质：JavaScript只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数。')])])]),n._v(" "),e("li",[e("p",[n._v("变量对象")]),n._v(" "),e("ul",[e("li",[n._v("变量数据是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。")]),n._v(" "),e("li",[n._v("全局对象：是预定义的对象，作为JavaScript的全局函数和全局属性的占位符。")]),n._v(" "),e("li",[n._v("在函数上下文中，变量对象包括：函数的所有形参，函数声明，变量声明。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("alert(x);      // function\nvar x = 10;\nalert(x);      // 10\nx = 20;\nfunction x() {};\nalert(x);      // 20\n")])])])]),n._v(" "),e("li",[e("p",[n._v("this")]),n._v(" "),e("ul",[e("li",[n._v("在一个函数上下文中，this由调用者提供，由调用函数的方式决定。如果调用括号()的左边是引用类型的值，this将设为引用类型值的 base对象。当this值为null是，其值会被隐士转换为全局对象。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("(function () {\n  alert(this); // null => global\n})();\n")])])]),e("ul",[e("li",[n._v("局部变量，内部函数，形式参数存储在给定函数的激活对象中")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function foo() {\n   function bar() {\n      alert(this); // global 全局对象\n   }\n   bar(); // the same as AO.bar()\n}\n")])])])]),n._v(" "),e("li",[e("p",[n._v("闭包")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("定义：能够读取其他函数内部变量的函数或定义在一个函数内部的函数。")])]),n._v(" "),e("li",[e("p",[n._v("自由变量：指在函数中使用，但既不是函数参数也不是函数的局部变量的变量。")])]),n._v(" "),e("li",[e("p",[n._v("用途： 一个是可以读取函数内部的变量，另一个就是让这些变量的值始终保持在内存中。")])]),n._v(" "),e("li",[e("p",[n._v("使用注意点：")]),n._v(" "),e("ol",[e("li",[n._v("由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。")]),n._v(" "),e("li",[n._v("闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。")])])])])]),n._v(" "),e("li",[e("p",[n._v("斐波那契数列函数实现")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function fib(max) {\n\tvar t,a=0,b=1,arr=[0, 1];\n\twhile (arr.length < max) {\n\t\t[a, b] = [b, a+b];\n\t\tarr.push(b);\n\t}\n\treturn arr;\n}\n// 测试：\nfib(5);  // [0, 1, 1, 2, 3]\nfib(10);  // [0,1,1,2,3,5,8,13,21,34]\n")])])])])]),n._v(" "),e("p",[n._v("二、Web安全问题")]),n._v(" "),e("ul",[e("li",[n._v("XSS攻击：对Web页面注入脚本，使用JavaScript窃取用户信息，诱导用户操作。")]),n._v(" "),e("li",[n._v("CSRF攻击：伪造用户请求向网站发起恶意请求。")]),n._v(" "),e("li",[n._v("钓鱼攻击：利用网站的跳转链接或者图片制造钓鱼陷阱。")]),n._v(" "),e("li",[n._v("HTTP参数污染：利用对参数格式验证的不完善，对服务器进行参数注入攻击。")]),n._v(" "),e("li",[n._v("远程代码执行：用户通过浏览器提交执行命令，由于服务器端没有针对执行函数做过滤，导致在没有指定绝对的情况下就执行命令。")])]),n._v(" "),e("p",[n._v("三、Web安全解决方案")]),n._v(" "),e("ul",[e("li",[n._v("提供各种过滤模板函数，防止钓鱼或xss攻击；")]),n._v(" "),e("li",[n._v("添加常见的Web安全头的支持；")]),n._v(" "),e("li",[n._v("CSRF的防御方案；")]),n._v(" "),e("li",[n._v("定制白名单，用于安全跳转和url过滤；")]),n._v(" "),e("li",[n._v("各种模板相关的工具函数做预处理；")])]),n._v(" "),e("p",[n._v("四、常规知识点")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("SVN和Git的区别：")]),n._v(" "),e("ul",[e("li",[n._v("SVN优点：集中式服务器，已于管理，安全性高，管理方便。代码一致性高，适合开发人数不多的项目开发。")]),n._v(" "),e("li",[n._v("Svn缺点：服务器压力太大，数据库容量暴增。离线无法工作。")]),n._v(" "),e("li",[n._v("Git优点：分布式开发，公共服务器压力和数据量都不大，速度快，灵活，容易解决冲突，可离线工作。")]),n._v(" "),e("li",[n._v("Git缺点：学习周期相对比较长，代码保密性差，库克隆就可以完全公开所有代码和版本信息。")])])]),n._v(" "),e("li",[e("p",[n._v("栈内存和堆内存的区别：基本类型一般保存在栈内存，引用类型指保存在堆内存的对象。")])]),n._v(" "),e("li",[e("p",[n._v("从输入URL到页面加载的过程：")]),n._v(" "),e("ol",[e("li",[n._v("在浏览器地址栏中输入url")]),n._v(" "),e("li",[n._v("浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。")]),n._v(" "),e("li",[n._v("需要域名解析(DNS解析)，解析获取相应的IP地址；")]),n._v(" "),e("li",[n._v("浏览器根据IP地址与服务器建立socket连接；(三次握手连接，TCP协议)")]),n._v(" "),e("li",[n._v("浏览器与服务器通信：浏览器请求，服务器处理请求；")]),n._v(" "),e("li",[n._v("说明：浏览器根据URL 内容生成 HTTP请求，请求中包含请求文件的位置、请求文件的方式等；服务器接到请求后，根据HTTP请求中的内容来决定如何获取相应的HTML文件；服务器将得到的HTMLwenj发送给浏览器；在浏览器还没有完全接收HTML文件时便开始渲染、显示网页；在执行HTML中代码时，根据需要，浏览器会继续请求网页、CSS、JavaScript等文件。")]),n._v(" "),e("li",[n._v("浏览器接收到HTTP响应")]),n._v(" "),e("li",[n._v("读取页面内容，浏览器渲染，解析html源码")]),n._v(" "),e("li",[n._v("生成Dom树，解析css样式，js交互")]),n._v(" "),e("li",[n._v("浏览器与服务器断开连接")])])]),n._v(" "),e("li",[e("p",[n._v("页面优化方案")]),n._v(" "),e("ol",[e("li",[n._v("减少http请求，合理设置HTTP缓存；")]),n._v(" "),e("li",[n._v("使用浏览器缓存，在http请求头设置 cache-control 和 expires属性，可设定浏览器缓存。")]),n._v(" "),e("li",[n._v("启用压缩，在服务器端对文件进行压缩，在浏览器端对文件解压缩，减少通信传输的数据量。")]),n._v(" "),e("li",[n._v("CSS Sprites，合并CSS图片，减少请求，或者使用svg字体图标；")]),n._v(" "),e("li",[n._v("图片懒加载，优先加载首屏图片，剩余图片滚动是再加载；")]),n._v(" "),e("li",[n._v("CSS文件放在页面最上部，JavaScript文件放在页面最下面；")]),n._v(" "),e("li",[n._v("减少cookie传输，太大的cookie会严重影响数据传输，考虑静态资源使用独立域名访问。")]),n._v(" "),e("li",[n._v("JavaScript代码优化：尽量少的操作DOM,减少页面的重排和重绘；减少作用域链的查找，优化数据大操作，减少字符串的拼接")]),n._v(" "),e("li",[n._v("CSS选择符优化：减少ID和元素类名的使用，减少类名的嵌套层级")]),n._v(" "),e("li",[n._v("使用CDN加速缓存")]),n._v(" "),e("li",[n._v("反向代理")])])]),n._v(" "),e("li",[e("p",[n._v("跨域解决方案")]),n._v(" "),e("ul",[e("li",[n._v("定义：一个域下的文档或脚本试图去请求另一个域下的资源，狭义上指由浏览器同源策略限制的一类请求场景。")]),n._v(" "),e("li",[n._v('同源策略/SOP：一种约定，浏览器核心和最基本的安全功能，所谓同源是指"协议+域名+端口"三者相同。即便两个不同的域名指向同一个ip地址，也非同源。')]),n._v(" "),e("li",[n._v("同源限制的行为：1. Cookie、LocalStorage 和 IndexDB 无法获取。2. DOM 和 JS 对象无法获得。 3. AJAX 请求不能发送。")]),n._v(" "),e("li",[n._v("常见的解决方案：1、通过 jsonp 跨域；2、iframe跨域；3、postMessage跨域；4、跨域资源共享(CORS); 5、nginx代理跨域；6、nodejs中间件代理跨域；7、WebSocket协议跨域。")])]),n._v(" "),e("ol",[e("li",[e("p",[n._v("通过jsonp跨域方案")]),n._v(" "),e("ul",[e("li",[n._v("通常为了减轻web服务器的负载，我们把js、css、img等静态资源分离到另一台独立域名的服务器上面。在html页面中再通过相应的标签从不同域名下加载静态资源，被浏览器允许。故可通过动态创建script，再请求一个带参网址实现跨域通信。")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 通过原生实现\n<script>\n\tvar script = document.createElement('script');\n\tscript.type = 'text/javascript';\n\t\n\t// 传参并指定回调执行函数为 onBack\n\tscript.src = 'http://www.domain2.com:8080/login?user=admin&callback=onBack';\n\tdocument.head.appendChild(script);\n\t\n\t// 回调执行函数\n\tfunction onBack(res) {\n\t\talert(JSON.stringify(res));\n\t}\n<\/script>\n")])])]),e("p",[n._v("缺点：只能实现 get 一种请求。")])]),n._v(" "),e("li",[e("p",[n._v("postMessage跨域")]),n._v(" "),e("ul",[e("li",[n._v('用法：postMessage(data, origin),接收两个参数：data -- 任意基本类型或可复制对象。origin: 协议+主机+端口号，也可设置为"*"。同源可设置为"/";')]),n._v(" "),e("li",[n._v("解决问题：a. 页面和其打开的新窗口的数据传递；b.多窗口之间消息传递；c.页面与嵌套的iframe消息传递。d.上面三个场景的跨数据传递。")])])]),n._v(" "),e("li",[e("p",[n._v("跨资源共享(CORS)\n普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求，前后端都需要设置。但由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie,而非当前页，需做代理设置。")])]),n._v(" "),e("li",[e("p",[n._v("nginx代理跨域")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("nginx配置解决iconfont跨域")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("location / {\n\tadd_header Access-Control-Allow-Origin *;\n}\n")])])])]),n._v(" "),e("li",[e("p",[n._v("nginx反向代理接口跨域")]),n._v(" "),e("ol",[e("li",[n._v("跨域原理：同源策略是浏览器的安全策略，不是HTTP协议的一部分，服务端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨域问题。")]),n._v(" "),e("li",[n._v("实现思路：通过nginx配置一个代理服务器(域名相同，端口不同)做跳板，反向代理访问domain2接口，并顺便修改cookie中的domain信息，方便当前域cookie写入，实现跨域登录。\nnginx的具体配置")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("#proxy服务器\nserver {\n    listen       81;\n    server_name  www.domain1.com;\n\n    location / {\n        proxy_pass   http://www.domain2.com:8080;  #反向代理\n        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名\n        index  index.html index.htm;\n\n        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用\n        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*\n        add_header Access-Control-Allow-Credentials true;\n    }\n}\n")])])]),e("p",[n._v("前端代码实例：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var xhr = new XMLHttpRequest();\n\n// 前端开关：浏览器是否读写cookie\nxhr.withCredentials = true;\n\n// 访问nginx中的代理服务器\nxhr.open('get', 'http://www.domain1.com:81/?user=admin', true);\nxhr.send();\n")])])])])])]),n._v(" "),e("li",[e("p",[n._v("WebSocket协议跨域：HTML5新的协议，实现了浏览器与服务器全双工通信，同时允许跨域通讯。")])])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 前端代码实现\n<div>user input：<input type=\"text\"></div>\n<script src=\"./socket.io.js\"><\/script>\n<script>\nvar socket = io('http://www.domain2.com:8080');\n\n// 连接成功处理\nsocket.on('connect', function() {\n    // 监听服务端消息\n    socket.on('message', function(msg) {\n        console.log('data from server: ---\x3e ' + msg); \n    });\n\n    // 监听服务端关闭\n    socket.on('disconnect', function() { \n        console.log('Server socket has closed.'); \n    });\n});\n\ndocument.getElementsByTagName('input')[0].onblur = function() {\n    socket.send(this.value);\n};\n<\/script>\n")])])])])])])}],!1,null,null,null);v.options.__file="JavaScript语言特性.md";t.default=v.exports}}]);